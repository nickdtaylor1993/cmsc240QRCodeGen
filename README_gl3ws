//author: Georgi Lekov

I have worked on the following classes:
APLT - alignment pattert location table
ECCgenerator
ECC_Table
Parser
QRCodeGenerator
QRCode
Encoder
CC_Table

and the driver file of the project qrgen.cpp

I will start by discussing the overall design of the program, with accent on
how my code fits in the big picture:
The ECCgenerator class is generates error correction codewords for a user
designated level of error correction. The ecc-words generated correspond to
given data codewords by Amanda and her class Encoder(and child classes).  The
generated ecc-words are interleaved with the data-words by the Interleaver.
After they are combined, the result is converted into binary and stored in a
QRCode object, along with the version and ecc_level used in the process of
encoding. This QRCode object is then used to populate a ModuleMatrix, which in
the end is displayed by the Viewer to the GUI user.

ECCgenerator:
The most important of the classes I worked on is ECCgenerator. The class has 2
public methods, one of which is getECC. When passed vector of data codewords,
it returns the corresponding vector of ecc_words. It first splits the data
codewords into the appropriate blocks. All information about the correlation
between: version , eec-level, number of blocks in group 1 and 2, number of data
codewords in blocks in group 1 and 2 and number of ecc-words in blocks is
conveniently accessed with an object of ECC_Table.

After the input message (data-codewords) have been split into blocks, each
block is processed, and the appropriate ecc-words are generated. All the
ecc-words for each block are combined and are returned to the user. 

The ecc-words for a specific block are generated by first determining the
amount of ecc-words needed per block, and then the message polynomial is
divided by the message polynomial. The generator polynomial is grabbed from the
gen_polys table I have in the class. Then the message polynomial is divided by
the generator polynomial.

I chose to hardcode the generator polynomials because they are less than 10,
and the procedure of generating them is actually pretty complicated. This saved
me time during development, and is actually is a much better approach in terms
of time efficiency. The whole trick is that you don't need to know all the
possible generator polynomials, but rather only those used in QR codes.

I would also like to express my apologies for the sloppy code at some points.
For example, a couple of times copying of vectors is used, instead of passing
by reference. I decided to set those "optimization" concerns asside, and focuns
on the other part of our project that was falling behind.

=======================================
Testing for ECCgenerator:
=======================================
Now a tricky problem that I had to solve was how to make sure my program works.
And that doesn't mean to just run it with the example from Thonky.com, because
even if it works, the probability of it working for other messages is minimal.
And that's what happened in reality actually. I made it work with the example
from Thonky, and when I tried other ones, it failed.

This is my algorithm for testing:
I pick a certain QR code version and ecc_level from the ECC_Table. The total
number of data codewords for this version and level are specified in the table.
These codewords can be any number in the range [0, 255]. So I decided to create
my own random codeword generator (RCG for short). It generates such codewords
for me, the amount of which I specify as a command line argument, and it prints
them to the screen. I copy them, and this is the input that my encoder will
receive.

I used an online calculator(link in testing files) which given a list of
codewords generates a user-specified number of ecc_words. So I was able to use
their work, to test the correctness of mine (it even has tables, each
calculation is displayed step by step, really useful!). I tried different
version and levels of error correction, and kept everything in sync with the
data from the table. 

ECC_Table, CC_Table, APLT:
These classes are simply the implementation of the tables from thonky.com. They
are very useful and provide a good layer of abstraction for the user.

Parser:
The parser class is extremely useful, because it provides an abstraction
between the commandline arguments and our defined types ("L" vs ECC_L). It also
does error checking.
